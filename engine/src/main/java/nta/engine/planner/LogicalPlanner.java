package nta.engine.planner;

import nta.engine.Context;
import nta.engine.parser.QueryAnalyzer;
import nta.engine.parser.QueryBlock;
import nta.engine.parser.QueryBlock.FromTable;
import nta.engine.planner.logical.GroupbyNode;
import nta.engine.planner.logical.JoinNode;
import nta.engine.planner.logical.LogicalNode;
import nta.engine.planner.logical.ProjectionNode;
import nta.engine.planner.logical.ScanNode;
import nta.engine.planner.logical.SelectionNode;
import nta.engine.planner.logical.SortNode;
import nta.engine.query.exception.NotSupportQueryException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This class creates a logical planner from a parse tree ({@link QueryBlock})
 * generated by {@link QueryAnalyzer}.
 * 
 * @author Hyunsik Choi
 *
 * @see QueryBlock
 */
public class LogicalPlanner {
  private Log LOG = LogFactory.getLog(LogicalPlanner.class);

  private LogicalPlanner() {
  }

  /**
   * This generates a logical plan.
   * 
   * @param query a parse tree
   * @return a initial logical plan
   */
  public static LogicalNode createPlan(Context ctx, QueryBlock query) {

    LogicalNode plan = null;    

    switch(query.getStatementType()) {    

    case SELECT:
      plan = createSelectPlan(ctx, query);
      break;

    default:;
    throw new NotSupportQueryException(query.toString());
    }

    return plan;
  }
  
  /**
   * ^(SELECT from_clause? where_clause? groupby_clause? selectList)
   * 
   * @param query
   * @return
   */
  private static LogicalNode createSelectPlan(Context ctx, QueryBlock query) {
    LogicalNode subroot = null;
    if(query.hasFromClause()) {
       subroot = createJoinTree(ctx, query.getFromTables());
    }
    
    if(query.hasWhereClause()) {
      SelectionNode selNode = 
          new SelectionNode(query.getWhereCondition());
      selNode.setSubNode(subroot);
      subroot = selNode;
    }
    
    if(query.getProjectAll()) {      
    } else {
      ProjectionNode prjNode = new ProjectionNode(query.getTargetList());
      prjNode.setSubNode(subroot);
      subroot = prjNode;
    }
    
    if(query.hasGroupbyClause()) {
      GroupbyNode groupbyNode = new GroupbyNode(query.getGroupFields());
      if(query.hasHavingCond())
        groupbyNode.setHavingCondition(query.getHavingCond());
      
      groupbyNode.setSubNode(subroot);
      subroot = groupbyNode;
    }
    
    if(query.hasOrderByClause()) {
      SortNode sortNode = new SortNode(query.getSortKeys());
      sortNode.setSubNode(subroot);
      subroot = sortNode;
    }
    return subroot;  
  }
  
  private static LogicalNode createJoinTree(Context ctx, FromTable [] tables) {
    LogicalNode subroot = null;
    
    subroot = new ScanNode(tables[0]);
    if(tables.length > 1) {    
      for(int i=1; i < tables.length; i++) {
        subroot = new JoinNode(new ScanNode(tables[i]), subroot);
      }
    }
    
    return subroot;
  }
}
